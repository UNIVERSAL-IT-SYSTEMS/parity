Configuration directives supported by parity:
=============================================

BackendType (ToolchainType)
	Describes the type of Backend to use. This is used to decide which form
	of paths to use, wether command scripts are allowed, etc.
	
CtxDump (bool)
	Specifies wether the whole internal parity context should be dumped on
	the terminal. this is done using debug output with level verbose, so nothing
	will be written, if the debug level is less then verbose.
	
Colored (bool)
	Specifies wether the output should be colored. This not only colors paritys
	output, but also the output from the target compiler and linker.

ColorMode (Color::ColorMode)
	Can be either "light" or "dark", describing the console background which
	is in use. Colors are chosen so that the output will be readable on the given
	type of terminal background.

GatherSystem (bool)
	Specifies wether system libraries should be taken into account when gathering
	symbol information. This does not bring any real advantage, except that system
	libraries can be preloaded with LD_PRELOAD. Be aware that this takes quite some
	time, even when linking one-liners.

GenerateLoader (bool)
	Specifies wether a custom loader should be generated. This is enabled by default,
	and makes features like LD_PRELOAD, hardcoded run-paths, lazy loading, etc.
	possible. Without this directive enabled, all the above things will not be
	available.

LazyLoading (bool)
	Specifies wether lazy loading stubs should be generated. When GenerateLoader is
	enabled, parity generates stubs, that redirect to the real shared library symbols
	(only for functions of course). If Lazy loading is enabled at link time, those
	stubs get more complex, calling a routine from parity.loader, which knows how to
	load the corresponding symbol. This makes binaries a little larger, since symbol
	names have to be stored in the binary. This effectlively swaps loading times from
	startup- to run-time. However, the loader still does a LoadLibrary on every required
	library at startup time, since it has to load all data symbols. So Lazy loading only
	pays if there are very many functions to load from shared libraries, where possibly
	only a few of them are ever called during runtime.

ParityLoader (Path)
PCRTLibrary (Path)
PCRTInclude (Path)
EntryPoint (std::string)
SharedEntryPoint (std::string)
RunPaths (PathVector)
KeepTemporary (bool)
TimingShowTasks (bool)
StatisticsFile (Path)
IgnoreOutputFilters (bool)
AdditionalExecPaths (PathVector)
GeneratePCRTEntry (bool)
GenerateSymbols (bool)
UseCommandScripts (bool)
ExportAll (bool)
ExportFromExe (bool)
KeepComments (bool)
NoStdIncludes (bool)
Defines (DefineMap)
IncludePaths (PathVector)
SysIncludePaths (PathVector)
OptimizeLevel (long)
OmitFramePointer (bool)
InlineFunctions (bool)
UseSSE (bool)
UseSSE2 (bool)
ForScope (bool)
MsExtensions (bool)
WarningLevel (long)
WarningAsError (bool)
ExceptionHandling (bool)
RuntimeTypes (bool)
ShortWchar (bool)
CompilerDefaults (std::string)
AssemblerDefaults (std::string)
CompilerExe (Path)
AssemblerExe (Path)
TimeT32Bit (bool)
Runtime (RuntimeType)
ForcedLanguage (LanguageType)
AnsiMode (bool)
StackReserve (long)
StackCommit (long)
HeapReserve (long)
HeapCommit (long)
LibraryPaths (PathVector)
LinkerSharedDefaults (std::string)
LinkerDefaults (std::string)
LinkerExe (Path)
SysLibraryPaths (PathVector)
ObjectsLibraries (PathVector)
ForceLink (bool)
Subsystem (SubsystemType)
ManifestExe (Path)
ManifestDefaults (std::string)
DefaultOutput (Path)
